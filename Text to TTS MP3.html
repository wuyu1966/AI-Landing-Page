<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>文本提取与TTS朗读工具</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <!-- 引入编码处理库 -->
  <script src="https://cdn.jsdelivr.net/npm/jschardet@3.0.0/dist/jschardet.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/iconv-lite@0.6.3/dist/iconv-lite.min.js"></script>
  
  <!-- 引入音频处理库 -->
  <script src="https://cdn.jsdelivr.net/npm/wavencoder@2.0.0/dist/wavencoder.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
  
  <!-- 配置Tailwind自定义主题 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            accent: '#8B5CF6',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            inter: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .text-shadow {
        text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .transition-custom {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .glass-effect {
        backdrop-filter: blur(10px);
        background-color: rgba(255, 255, 255, 0.7);
      }
      .glass-effect-dark {
        backdrop-filter: blur(10px);
        background-color: rgba(30, 41, 59, 0.7);
      }
      .recording-indicator {
        animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
    }
  </style>
</head>

<body class="font-inter bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-slate-900 dark:to-blue-950 min-h-screen text-slate-800 dark:text-slate-100 transition-custom">
  <!-- 页面容器 -->
  <div class="container mx-auto px-4 py-8 max-w-6xl">
    <!-- 头部区域 -->
    <header class="mb-10 text-center">
      <div class="flex justify-center items-center mb-2">
        <i class="fa fa-volume-up text-primary text-3xl mr-3 animate-pulse"></i>
        <h1 class="text-[clamp(1.8rem,5vw,3rem)] font-bold text-primary dark:text-blue-400 text-shadow">
          文本提取与TTS朗读工具
        </h1>
      </div>
      <p class="text-slate-600 dark:text-slate-300 text-lg max-w-2xl mx-auto">
        输入文本或上传文件，提取内容并使用浏览器内置TTS进行朗读，支持导出音频
      </p>
      
      <!-- 主题切换按钮 -->
      <button id="theme-toggle" class="mt-4 p-2 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-custom">
        <i class="fa fa-moon-o dark:hidden text-slate-700"></i>
        <i class="fa fa-sun-o hidden dark:block text-yellow-300"></i>
      </button>
    </header>

    <!-- 主要内容区域 -->
    <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- 左侧：文本输入与文件上传 -->
      <div class="lg:col-span-2 space-y-6">
        <!-- 文本输入区域 -->
        <section class="bg-white dark:bg-slate-800 rounded-2xl shadow-lg p-6 transform hover:shadow-xl transition-custom">
          <h2 class="text-xl font-semibold mb-4 flex items-center justify-between">
            <div><i class="fa fa-file-text-o text-primary mr-2"></i>文本输入</div>
            <span class="text-xs text-slate-500 dark:text-slate-400">
              <span id="char-count">0</span> 字符
            </span>
          </h2>
          <textarea 
            id="text-input" 
            class="w-full h-48 p-4 border border-slate-300 dark:border-slate-600 rounded-lg bg-slate-50 dark:bg-slate-900 focus:ring-2 focus:ring-primary focus:border-transparent transition-custom resize-none"
            placeholder="在此输入要朗读的文本..."></textarea>
          <div class="text-xs text-slate-500 dark:text-slate-400 mt-1">
            <span id="recording-note" class="hidden text-amber-600 dark:text-amber-400">
              <i class="fa fa-info-circle mr-1"></i>提示：过长文本可能导致转换失败，请分段处理
            </span>
          </div>
        </section>
        
        <!-- 文件上传区域 -->
        <section class="bg-white dark:bg-slate-800 rounded-2xl shadow-lg p-6 transform hover:shadow-xl transition-custom">
          <h2 class="text-xl font-semibold mb-4 flex items-center">
            <i class="fa fa-upload text-primary mr-2"></i>文件上传
          </h2>
          <div id="file-upload-area" class="border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-lg p-8 text-center hover:border-primary transition-custom cursor-pointer">
            <i class="fa fa-file-text text-5xl text-slate-400 mb-4"></i>
            <p class="mb-2">拖放文本文件到此处，或</p>
            <label class="inline-block bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg cursor-pointer transition-custom">
              <i class="fa fa-folder-open mr-1"></i>选择文件
              <input type="file" id="file-input" accept=".txt" class="hidden">
            </label>
            <p class="text-sm text-slate-500 dark:text-slate-400 mt-3">支持 .txt 格式文件</p>
          </div>
          <div id="file-info" class="mt-4 hidden">
            <div class="flex items-center justify-between p-3 bg-slate-100 dark:bg-slate-700 rounded-lg">
              <div class="flex items-center">
                <i class="fa fa-file-text-o text-primary mr-2"></i>
                <span id="file-name" class="truncate max-w-[70%]"></span>
              </div>
              <button id="clear-file" class="text-slate-500 hover:text-red-500 transition-custom">
                <i class="fa fa-times"></i>
              </button>
            </div>
            
            <!-- 编码信息和选择器 -->
            <div class="mt-3 flex flex-col sm:flex-row sm:items-center gap-2">
              <div class="flex-1">
                <label class="text-sm font-medium">检测到编码：</label>
                <span id="detected-encoding" class="ml-2 text-sm bg-blue-100 dark:bg-blue-900 px-2 py-1 rounded">未知</span>
              </div>
              <div class="flex-1">
                <label for="manual-encoding" class="text-sm font-medium">手动指定编码：</label>
                <select id="manual-encoding" class="ml-2 p-1 border rounded text-sm bg-slate-50 dark:bg-slate-900">
                  <option value="auto">自动检测（默认）</option>
                  <option value="utf8">UTF-8</option>
                  <option value="gbk">GBK/GB2312</option>
                  <option value="utf16le">UTF-16 LE</option>
                  <option value="utf16be">UTF-16 BE</option>
                  <option value="big5">BIG5 (繁体中文)</option>
                  <option value="iso-8859-1">ISO-8859-1 (西欧)</option>
                </select>
              </div>
            </div>
          </div>
        </section>
        
        <!-- 提取的文本预览 -->
        <section class="bg-white dark:bg-slate-800 rounded-2xl shadow-lg p-6 transform hover:shadow-xl transition-custom">
          <h2 class="text-xl font-semibold mb-4 flex items-center justify-between">
            <div><i class="fa fa-eye text-primary mr-2"></i>提取的文本预览</div>
            <button id="copy-text" class="text-sm text-primary hover:text-primary/80 flex items-center">
              <i class="fa fa-copy mr-1"></i>复制
            </button>
          </h2>
          <div id="text-preview" class="w-full min-h-[120px] p-4 border border-slate-300 dark:border-slate-600 rounded-lg bg-slate-50 dark:bg-slate-900 overflow-auto">
            <p class="text-slate-400 dark:text-slate-500 italic text-center">提取的文本将显示在这里...</p>
          </div>
          <div class="mt-4 flex justify-end">
            <button id="extract-text" class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-custom flex items-center">
              <i class="fa fa-magic mr-2"></i>提取文本
            </button>
          </div>
        </section>
      </div>
      
      <!-- 右侧：TTS控制区域 -->
      <div class="space-y-6">
        <!-- TTS控制 -->
        <section class="bg-white dark:bg-slate-800 rounded-2xl shadow-lg p-6 transform hover:shadow-xl transition-custom sticky top-4">
          <h2 class="text-xl font-semibold mb-6 flex items-center">
            <i class="fa fa-volume-up text-primary mr-2"></i>TTS朗读控制
          </h2>
          
          <!-- 朗读进度指示器 -->
          <div id="progress-container" class="h-2 bg-slate-200 dark:bg-slate-700 rounded-full mb-6 hidden">
            <div id="progress-bar" class="h-full bg-primary rounded-full w-0 transition-all duration-150"></div>
          </div>
          
          <!-- 控制按钮 -->
          <div class="flex justify-center space-x-4 mb-8">
            <button id="play-btn" class="w-16 h-16 rounded-full bg-green-500 hover:bg-green-600 text-white flex items-center justify-center shadow-lg hover:shadow-xl transition-custom disabled:opacity-50 disabled:cursor-not-allowed">
              <i class="fa fa-play text-2xl"></i>
            </button>
            <button id="pause-btn" class="w-16 h-16 rounded-full bg-amber-500 hover:bg-amber-600 text-white flex items-center justify-center shadow-lg hover:shadow-xl transition-custom disabled:opacity-50 disabled:cursor-not-allowed" disabled>
              <i class="fa fa-pause text-2xl"></i>
            </button>
            <button id="stop-btn" class="w-16 h-16 rounded-full bg-red-500 hover:bg-red-600 text-white flex items-center justify-center shadow-lg hover:shadow-xl transition-custom disabled:opacity-50 disabled:cursor-not-allowed" disabled>
              <i class="fa fa-stop text-2xl"></i>
            </button>
          </div>
          
          <!-- 转换与下载按钮 -->
          <div class="flex justify-center space-x-4 mb-8">
            <button id="convert-btn" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg transition-custom flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
              <i class="fa fa-magic mr-2"></i>转换为MP3
            </button>
            <button id="download-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg transition-custom flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
              <i class="fa fa-download mr-2"></i>下载MP3
            </button>
          </div>
          
          <!-- 语音设置 -->
          <div class="space-y-4">
            <div>
              <label for="voice-select" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">选择语音</label>
              <select id="voice-select" class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-slate-50 dark:bg-slate-900 focus:ring-2 focus:ring-primary focus:border-transparent transition-custom">
                <option value="">加载语音中...</option>
              </select>
            </div>
            
            <div>
              <label for="rate" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">语速: <span id="rate-value">1</span></label>
              <input type="range" id="rate" min="0.5" max="2" step="0.1" value="1" class="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary">
            </div>
            
            <div>
              <label for="pitch" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">音调: <span id="pitch-value">1</span></label>
              <input type="range" id="pitch" min="0.5" max="2" step="0.1" value="1" class="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary">
            </div>
            
            <div>
              <label for="volume" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">音量: <span id="volume-value">1</span></label>
              <input type="range" id="volume" min="0" max="1" step="0.1" value="1" class="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary">
            </div>
          </div>
          
          <!-- 保存/加载设置 -->
          <div class="mt-4 flex gap-2">
            <button id="save-settings" class="flex-1 bg-secondary hover:bg-secondary/90 text-white text-sm font-medium py-1.5 px-3 rounded-lg transition-custom">
              <i class="fa fa-save mr-1"></i>保存设置
            </button>
            <button id="load-settings" class="flex-1 bg-accent hover:bg-accent/90 text-white text-sm font-medium py-1.5 px-3 rounded-lg transition-custom">
              <i class="fa fa-refresh mr-1"></i>加载设置
            </button>
          </div>
          
          <!-- 状态信息 -->
          <div id="status-info" class="mt-6 p-3 rounded-lg bg-slate-100 dark:bg-slate-700 text-center text-sm hidden">
            <p id="status-message" class="text-slate-700 dark:text-slate-200"></p>
          </div>
          
          <!-- 浏览器提示 -->
          <div class="mt-6 p-3 rounded-lg bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-800 text-sm">
            <p class="text-blue-700 dark:text-blue-300 flex items-center">
              <i class="fa fa-info-circle mr-2"></i>
              MP3音频导出功能在Chrome、Edge浏览器中体验最佳
            </p>
          </div>
          
          <!-- 音频播放预览 -->
          <div id="audio-preview" class="mt-6 hidden">
            <h3 class="text-sm font-medium mb-2">MP3音频预览</h3>
            <audio id="preview-audio" controls class="w-full"></audio>
          </div>
        </section>
      </div>
    </main>
    
    <!-- 页脚 -->
    <footer class="mt-16 text-center text-slate-500 dark:text-slate-400 text-sm">
      <p>© 2023 文本提取与TTS朗读工具 | 使用Web Speech API技术</p>
    </footer>
  </div>
  
  <!-- 通知组件 -->
  <div id="notification" class="fixed bottom-4 right-4 p-4 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300 max-w-xs hidden z-50 glass-effect dark:glass-effect-dark"></div>

  <script>
    // DOM元素
    const themeToggle = document.getElementById('theme-toggle');
    const textInput = document.getElementById('text-input');
    const charCount = document.getElementById('char-count');
    const fileInput = document.getElementById('file-input');
    const fileUploadArea = document.getElementById('file-upload-area');
    const fileInfo = document.getElementById('file-info');
    const fileName = document.getElementById('file-name');
    const clearFile = document.getElementById('clear-file');
    const textPreview = document.getElementById('text-preview');
    const extractTextBtn = document.getElementById('extract-text');
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const stopBtn = document.getElementById('stop-btn');
    const convertBtn = document.getElementById('convert-btn');
    const downloadBtn = document.getElementById('download-btn');
    const voiceSelect = document.getElementById('voice-select');
    const rateInput = document.getElementById('rate');
    const pitchInput = document.getElementById('pitch');
    const volumeInput = document.getElementById('volume');
    const rateValue = document.getElementById('rate-value');
    const pitchValue = document.getElementById('pitch-value');
    const volumeValue = document.getElementById('volume-value');
    const statusInfo = document.getElementById('status-info');
    const statusMessage = document.getElementById('status-message');
    const notification = document.getElementById('notification');
    const detectedEncoding = document.getElementById('detected-encoding');
    const manualEncoding = document.getElementById('manual-encoding');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const copyTextBtn = document.getElementById('copy-text');
    const saveSettingsBtn = document.getElementById('save-settings');
    const loadSettingsBtn = document.getElementById('load-settings');
    const recordingNote = document.getElementById('recording-note');
    const audioPreview = document.getElementById('audio-preview');
    const previewAudio = document.getElementById('preview-audio');
    
    // 全局变量
    let currentFile = null;
    let speechSynthesis = window.speechSynthesis;
    let utterance = null;
    let voices = [];
    let isPaused = false;
    let totalChars = 0;
    let spokenChars = 0;
    
    // 音频相关变量
    let audioContext = null;
    let audioDestination = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isConverting = false;
    let audioBlob = null;
    let audioUrl = null;
    let audioStarted = false;
    let mp3Encoder = null;
    
    // 初始化
    document.addEventListener('DOMContentLoaded', () => {
      // 检查主题偏好
      if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
      
      // 加载语音列表
      loadVoices();
      
      // 如果语音合成API准备就绪，再次加载语音
      speechSynthesis.onvoiceschanged = loadVoices;
      
      // 初始化字符计数
      updateCharCount();
      
      // 尝试加载保存的设置
      loadSavedSettings();
      
      // 检查文本长度，显示转换提示
      checkTextLengthForConversion();
      
      // 检查浏览器兼容性
      checkBrowserCompatibility();
    });
    
    // 检查浏览器兼容性
    function checkBrowserCompatibility() {
      if (!('speechSynthesis' in window)) {
        showNotification('您的浏览器不支持语音合成功能', 'error');
        document.querySelectorAll('#play-btn, #pause-btn, #stop-btn, #convert-btn').forEach(btn => {
          btn.disabled = true;
        });
      }
      
      if (!(window.MediaRecorder || window.webkitMediaRecorder)) {
        showNotification('您的浏览器不支持音频录制功能，无法导出音频', 'warning');
        convertBtn.disabled = true;
        downloadBtn.disabled = true;
      }
    }
    
    // 更新字符计数
    textInput.addEventListener('input', () => {
      updateCharCount();
      checkTextLengthForConversion();
    });
    
    function updateCharCount() {
      charCount.textContent = textInput.value.length;
    }
    
    // 检查文本长度，显示转换提示
    function checkTextLengthForConversion() {
      const textLength = textInput.value.length;
      if (textLength > 5000) {
        recordingNote.classList.remove('hidden');
      } else {
        recordingNote.classList.add('hidden');
      }
    }
    
    // 加载语音列表
    function loadVoices() {
      voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      
      // 添加默认选项
      const defaultOption = document.createElement('option');
      defaultOption.textContent = '默认语音';
      defaultOption.value = '';
      voiceSelect.appendChild(defaultOption);
      
      // 筛选中文语音优先显示
      const chineseVoices = voices.filter(voice => 
        voice.lang.includes('zh') || voice.name.includes('Chinese')
      );
      const otherVoices = voices.filter(voice => 
        !voice.lang.includes('zh') && !voice.name.includes('Chinese')
      );
      
      // 添加中文语音
      if (chineseVoices.length > 0) {
        const groupOption = document.createElement('optgroup');
        groupOption.label = '中文语音';
        chineseVoices.forEach(voice => {
          const option = document.createElement('option');
          option.textContent = `${voice.name} (${voice.lang})`;
          option.value = voice.name;
          groupOption.appendChild(option);
        });
        voiceSelect.appendChild(groupOption);
      }
      
      // 添加其他语音
      if (otherVoices.length > 0) {
        const groupOption = document.createElement('optgroup');
        groupOption.label = '其他语音';
        otherVoices.forEach(voice => {
          const option = document.createElement('option');
          option.textContent = `${voice.name} (${voice.lang})`;
          option.value = voice.name;
          groupOption.appendChild(option);
        });
        voiceSelect.appendChild(groupOption);
      }
      
      // 如果没有语音可用
      if (voices.length === 0) {
        const option = document.createElement('option');
        option.textContent = '未检测到可用语音';
        option.disabled = true;
        voiceSelect.appendChild(option);
        showNotification('未检测到TTS语音，请检查浏览器设置', 'warning');
      }
      
      // 恢复保存的语音设置
      const savedVoice = localStorage.getItem('savedVoice');
      if (savedVoice && voices.some(voice => voice.name === savedVoice)) {
        voiceSelect.value = savedVoice;
      }
    }
    
    // 主题切换
    themeToggle.addEventListener('click', () => {
      if (document.documentElement.classList.contains('dark')) {
        document.documentElement.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        document.documentElement.classList.add('dark');
        localStorage.theme = 'dark';
      }
    });
    
    // 文件上传处理
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });
    
    // 拖放文件处理
    fileUploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileUploadArea.classList.add('border-primary');
    });
    
    fileUploadArea.addEventListener('dragleave', () => {
      fileUploadArea.classList.remove('border-primary');
    });
    
    fileUploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      fileUploadArea.classList.remove('border-primary');
      
      if (e.dataTransfer.files.length > 0) {
        const file = e.dataTransfer.files[0];
        if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
          handleFile(file);
        } else {
          showNotification('请上传文本文件(.txt)', 'error');
        }
      }
    });
    
    fileUploadArea.addEventListener('click', () => {
      fileInput.click();
    });
    
    // 清除文件
    clearFile.addEventListener('click', () => {
      currentFile = null;
      fileInput.value = '';
      fileInfo.classList.add('hidden');
      showNotification('已清除文件');
    });
    
    // 处理文件
    function handleFile(file) {
      currentFile = file;
      fileName.textContent = file.name;
      fileInfo.classList.remove('hidden');
      
      // 预检测编码并显示
      const reader = new FileReader();
      reader.readAsArrayBuffer(file.slice(0, 1024 * 10)); // 读取前10KB用于预检测
      reader.onload = () => {
        const encoding = detectEncoding(reader.result);
        detectedEncoding.textContent = encoding || "未知";
        // 自动选择检测到的编码
        if (encoding && manualEncoding.value === "auto") {
          manualEncoding.value = encoding;
        }
      };
      
      showNotification(`已选择文件: ${file.name}`);
    }
    
    // 提取文本
    extractTextBtn.addEventListener('click', async () => {
      let text = '';
      
      // 从文本输入提取
      if (textInput.value.trim() !== '') {
        text = textInput.value.trim();
        text = cleanText(text);
      }
      // 从文件提取
      else if (currentFile) {
        try {
          text = await readFileWithEncoding(currentFile);
        } catch (error) {
          showEncodingError(error);
          console.error('读取文件失败:', error);
          return;
        }
      }
      // 没有可提取的文本
      else {
        showNotification('请输入文本或上传文件', 'warning');
        return;
      }
      
      // 显示提取的文本
      textPreview.innerHTML = text.replace(/\n/g, '<br>');
      showNotification('文本提取成功');
      
      // 启用控制按钮
      enableControlButtons();
      
      // 保存文本到localStorage
      localStorage.setItem('lastExtractedText', text);
      
      // 检查文本长度，显示转换提示
      checkTextLengthForConversion();
    });
    
    /**
     * 检测文本编码
     * @param {ArrayBuffer} buffer - 文件二进制数据
     * @returns {string} 编码格式（如"utf8"、"gbk"）
     */
    function detectEncoding(buffer) {
      const detection = jschardet.detect(buffer);
      let encoding = detection.encoding?.toLowerCase() || "utf8";
      
      // 简化编码名称
      if (encoding === "windows-1252") return "iso-8859-1";
      if (encoding === "utf-8") return "utf8";
      
      return encoding;
    }
    
    /**
     * 读取文件并转换为UTF-8文本
     * @param {File} file - 上传的文件
     * @returns {Promise<string>} 转换后的文本
     */
    function readFileWithEncoding(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = () => {
          try {
            const buffer = reader.result;
            // 优先使用用户手动指定的编码
            const manualEnc = document.getElementById("manual-encoding").value;
            const encoding = manualEnc !== "auto" ? manualEnc : detectEncoding(buffer);
            
            let text = "";
            
            // 处理不同编码
            if (encoding === "utf8") {
              text = new TextDecoder("utf-8").decode(buffer);
              text = text.replace(/^\ufeff/, ""); // 移除BOM
            } 
            // GBK/GB2312编码（中文常见编码）
            else if (["gbk", "gb2312", "gb18030"].includes(encoding)) {
              const uint8Buffer = new Uint8Array(buffer);
              text = iconv.decode(uint8Buffer, "gbk");
            } 
            // UTF-16编码（含LE/BE）
            else if (encoding.includes("utf-16")) {
              const isLittleEndian = encoding.includes("le");
              text = new TextDecoder(`utf-16${isLittleEndian ? "le" : "be"}`).decode(buffer);
              text = text.replace(/^\ufeff/, ""); // 移除BOM
            } 
            // 其他编码（尝试默认UTF-8容错）
            else {
              text = new TextDecoder("utf-8", { fatal: false, ignoreBOM: true }).decode(buffer);
            }
            
            resolve(cleanText(text));
          } catch (err) {
            reject(new Error(`编码转换失败：${err.message}`));
          }
        };
        
        reader.onerror = () => reject(new Error("文件读取失败"));
        reader.readAsArrayBuffer(file);
      });
    }
    
    /**
     * 清理文本中的无效字符
     */
    function cleanText(text) {
      return text
        // 移除控制字符（保留换行、回车、空格）
        .replace(/[\x00-\x09\x0B-\x1F\x7F-\x9F]/g, '')
        // 统一换行符
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .trim();
    }
    
    // 显示通知
    function showNotification(message, type = 'info') {
      notification.textContent = message;
      
      // 设置通知样式
      notification.className = 'fixed bottom-4 right-4 p-4 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300 max-w-xs z-50 glass-effect dark:glass-effect-dark';
      
      if (type === 'error') {
        notification.classList.add('text-red-600', 'dark:text-red-400', 'border', 'border-red-200', 'dark:border-red-800');
      } else if (type === 'warning') {
        notification.classList.add('text-amber-600', 'dark:text-amber-400', 'border', 'border-amber-200', 'dark:border-amber-800');
      } else {
        notification.classList.add('text-green-600', 'dark:text-green-400', 'border', 'border-green-200', 'dark:border-green-800');
      }
      
      // 显示通知
      notification.classList.remove('hidden', 'translate-y-20', 'opacity-0');
      
      // 3秒后隐藏
      setTimeout(() => {
        notification.classList.add('translate-y-20', 'opacity-0');
        setTimeout(() => {
          notification.classList.add('hidden');
        }, 300);
      }, 3000);
    }
    
    // 优化的编码错误提示
    function showEncodingError(error) {
      showNotification(
        `编码处理失败：${error.message}\n建议：1. 尝试手动选择编码 2. 保存文件为UTF-8格式再上传`,
        "error"
      );
    }
    
    // 更新语音参数显示
    rateInput.addEventListener('input', () => {
      rateValue.textContent = rateInput.value;
    });
    
    pitchInput.addEventListener('input', () => {
      pitchValue.textContent = pitchInput.value;
    });
    
    volumeInput.addEventListener('input', () => {
      volumeValue.textContent = volumeInput.value;
    });
    
    // 复制文本
    copyTextBtn.addEventListener('click', () => {
      const text = textPreview.textContent;
      if (text.trim() === '' || textPreview.querySelector('p.italic')) {
        showNotification('没有可复制的文本', 'warning');
        return;
      }
      
      navigator.clipboard.writeText(text)
        .then(() => showNotification('文本已复制到剪贴板'))
        .catch(err => {
          console.error('复制失败:', err);
          showNotification('复制失败，请手动复制', 'error');
        });
    });
    
    // 保存设置
    saveSettingsBtn.addEventListener('click', () => {
      const settings = {
        voice: voiceSelect.value,
        rate: rateInput.value,
        pitch: pitchInput.value,
        volume: volumeInput.value
      };
      
      localStorage.setItem('ttsSettings', JSON.stringify(settings));
      showNotification('设置已保存');
    });
    
    // 加载设置
    loadSettingsBtn.addEventListener('click', () => {
      loadSavedSettings();
      showNotification('已加载保存的设置');
    });
    
    // 加载保存的设置
    function loadSavedSettings() {
      const savedSettings = localStorage.getItem('ttsSettings');
      if (savedSettings) {
        try {
          const settings = JSON.parse(savedSettings);
          
          if (settings.voice && voices.some(voice => voice.name === settings.voice)) {
            voiceSelect.value = settings.voice;
          }
          
          if (settings.rate) {
            rateInput.value = settings.rate;
            rateValue.textContent = settings.rate;
          }
          
          if (settings.pitch) {
            pitchInput.value = settings.pitch;
            pitchValue.textContent = settings.pitch;
          }
          
          if (settings.volume) {
            volumeInput.value = settings.volume;
            volumeValue.textContent = settings.volume;
          }
        } catch (error) {
          console.error('加载保存的设置失败:', error);
        }
      }
      
      // 尝试加载上次提取的文本
      const lastText = localStorage.getItem('lastExtractedText');
      if (lastText) {
        textInput.value = lastText;
        updateCharCount();
        checkTextLengthForConversion();
      }
    }
    
    // 播放语音
    playBtn.addEventListener('click', () => {
      const text = textPreview.innerHTML.replace(/<br>/g, '\n').trim();
      
      if (text === '' || textPreview.querySelector('p.italic')) {
        showNotification('请先提取文本', 'warning');
        return;
      }
      
      // 如果正在暂停状态，继续播放
      if (isPaused && speechSynthesis.paused) {
        speechSynthesis.resume();
        updateStatus('继续朗读');
        updateControlButtons(false, true, true);
        return;
      }
      
      // 停止任何正在进行的语音
      stopSpeech();
      
      // 创建新的语音实例
      utterance = new SpeechSynthesisUtterance(text);
      
      // 设置语音参数
      const selectedVoice = voices.find(voice => voice.name === voiceSelect.value);
      if (selectedVoice) {
        utterance.voice = selectedVoice;
      }
      
      utterance.rate = parseFloat(rateInput.value);
      utterance.pitch = parseFloat(pitchInput.value);
      utterance.volume = parseFloat(volumeInput.value);
      
      // 计算总字符数用于进度显示
      totalChars = text.length;
      spokenChars = 0;
      
      // 事件监听
      utterance.onstart = () => {
        updateStatus('正在朗读...');
        updateControlButtons(false, true, true);
        progressContainer.classList.remove('hidden');
        progressBar.style.width = '0%';
      };
      
      utterance.onboundary = (event) => {
        // 更新朗读进度
        spokenChars = event.charIndex + event.charLength;
        const progress = Math.min((spokenChars / totalChars) * 100, 100);
        progressBar.style.width = `${progress}%`;
      };
      
      utterance.onend = () => {
        updateStatus('朗读已完成');
        updateControlButtons(true, false, false);
        isPaused = false;
        progressContainer.classList.add('hidden');
      };
      
      utterance.onerror = (event) => {
        updateStatus(`发生错误: ${event.error}`, 'error');
        updateControlButtons(true, false, false);
        isPaused = false;
        progressContainer.classList.add('hidden');
      };
      
      // 开始朗读
      speechSynthesis.speak(utterance);
    });
    
    // 暂停语音
    pauseBtn.addEventListener('click', () => {
      if (speechSynthesis.speaking) {
        if (speechSynthesis.paused) {
          // 继续播放
          speechSynthesis.resume();
          updateStatus('继续朗读');
          updateControlButtons(false, true, true);
          isPaused = false;
        } else {
          // 暂停播放
          speechSynthesis.pause();
          updateStatus('已暂停');
          updateControlButtons(true, false, true);
          isPaused = true;
        }
      }
    });
    
    // 停止语音
    stopBtn.addEventListener('click', () => {
      stopSpeech();
      updateStatus('已停止');
      updateControlButtons(true, false, false);
      isPaused = false;
      progressContainer.classList.add('hidden');
    });
    
    // 停止语音合成
    function stopSpeech() {
      if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
      }
    }
    
    // 转换为音频
    convertBtn.addEventListener('click', async () => {
      const text = textPreview.innerHTML.replace(/<br>/g, '\n').trim();
      
      if (text === '' || textPreview.querySelector('p.italic')) {
        showNotification('请先提取文本', 'warning');
        return;
      }
      
      if (isConverting) {
        finishConversion();
        return;
      }
      
      // 开始转换
      await startConversion(text);
    });
    
    // 开始转换为音频
    async function startConversion(text) {
      try {
        // 停止任何正在进行的语音
        stopSpeech();
        
        // 请求音频权限
        let userMediaStream = null;
        try {
          userMediaStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            } 
          });
        } catch (error) {
          console.warn('音频权限获取失败:', error);
          showNotification('请允许浏览器访问音频设备以获得最佳录制效果', 'warning');
        }
        
        // 初始化音频上下文
        if (!audioContext || audioContext.state === 'closed') {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        // 初始化录音器
        audioChunks = [];
        audioStarted = false;
        
        // 检查浏览器支持情况
        const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        
        // 根据浏览器兼容性选择合适的录音方式
        let mediaRecorderOptions = {
          audioBitsPerSecond: 128000
        };
        
        // 优先使用WAV格式，便于后续转换为MP3
        if (isChrome) {
          mediaRecorderOptions.mimeType = 'audio/wav';
        } 
        // Firefox更适合使用OGG
        else if (isFirefox) {
          mediaRecorderOptions.mimeType = 'audio/ogg; codecs=opus';
        } 
        // 其他浏览器使用默认
        else {
          mediaRecorderOptions.mimeType = 'audio/webm';
        }
        
        // 检查MIME类型支持
        if (MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {
          console.log(`使用支持的MIME类型: ${mediaRecorderOptions.mimeType}`);
        } else {
          console.log(`指定的MIME类型不支持，使用默认类型`);
          delete mediaRecorderOptions.mimeType;
        }
        
        // 创建MediaRecorder实例 - 使用系统音频流
        const streamToRecord = userMediaStream || audioDestination.stream;
        if (window.MediaRecorder) {
          mediaRecorder = new MediaRecorder(streamToRecord, mediaRecorderOptions);
        } else if (window.webkitMediaRecorder) {
          mediaRecorder = new window.webkitMediaRecorder(streamToRecord, mediaRecorderOptions);
        } else {
          throw new Error('您的浏览器不支持音频录制');
        }
        
        // 设置录音事件监听
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
            audioStarted = true;
            console.log('接收到音频数据块:', event.data.size, '字节');
          }
        };
        
        mediaRecorder.onstop = async () => {
          try {
            console.log('录音停止，检查音频数据...');
            console.log('音频块数量:', audioChunks.length);
            console.log('音频开始标志:', audioStarted);
            
            // 检查是否有音频数据
            if (!audioStarted || audioChunks.length === 0) {
              throw new Error('未能捕获到音频数据，请尝试以下操作：1. 确保您的浏览器允许访问音频设备 2. 尝试使用最新版Chrome或Edge浏览器 3. 缩短文本长度');
            }
            
            // 检查每个音频块的大小
            let totalSize = 0;
            audioChunks.forEach((chunk, index) => {
              console.log(`音频块 ${index}: ${chunk.size} 字节`);
              totalSize += chunk.size;
            });
            
            if (totalSize === 0) {
              throw new Error('所有音频块都为空，请检查音频设备权限');
            }
            
            // 合并音频块
            const originalBlob = new Blob(audioChunks, { type: mediaRecorderOptions.mimeType || 'audio/webm' });
            
            // 检查音频是否有效
            if (originalBlob.size === 0) {
              throw new Error('生成的音频文件为空，请尝试重新转换');
            }
            
            console.log('原始音频文件大小:', originalBlob.size, '字节');
            
            // 转换为MP3格式
            updateStatus('正在转换为MP3格式...');
            audioBlob = await convertToMP3(originalBlob);
            
            console.log('MP3音频文件大小:', audioBlob.size, '字节');
            
            // 创建音频URL
            if (audioUrl) {
              URL.revokeObjectURL(audioUrl);
            }
            audioUrl = URL.createObjectURL(audioBlob);
            
            // 更新预览音频
            previewAudio.src = audioUrl;
            audioPreview.classList.remove('hidden');
            
            // 启用下载按钮
            downloadBtn.disabled = false;
            
            // 更新状态
            updateStatus('MP3转换完成');
            showNotification('MP3音频转换完成，可以下载');
            
                    // 重置UI
        isConverting = false;
        convertBtn.innerHTML = '<i class="fa fa-magic mr-2"></i>转换为MP3';
        convertBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
        convertBtn.classList.add('bg-purple-500', 'hover:bg-purple-600');
            
            // 启用控制按钮
            enableControlButtons();
            
            // 清理音频流
            if (userMediaStream) {
              userMediaStream.getTracks().forEach(track => track.stop());
            }
          } catch (error) {
            console.error('处理音频数据失败:', error);
            showNotification('转换失败: ' + error.message, 'error');
            isConverting = false;
            convertBtn.innerHTML = '<i class="fa fa-magic mr-2"></i>转换为MP3';
            convertBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
            convertBtn.classList.add('bg-purple-500', 'hover:bg-purple-600');
            enableControlButtons();
            
            // 清理音频流
            if (userMediaStream) {
              userMediaStream.getTracks().forEach(track => track.stop());
            }
          }
        };
        
        mediaRecorder.onerror = (event) => {
          console.error('录音错误:', event.error);
          showNotification(`转换错误: ${event.error.name}`, 'error');
          isConverting = false;
          convertBtn.innerHTML = '<i class="fa fa-magic mr-2"></i>转换为MP3';
          convertBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
          convertBtn.classList.add('bg-purple-500', 'hover:bg-purple-600');
          enableControlButtons();
          
          // 清理音频流
          if (userMediaStream) {
            userMediaStream.getTracks().forEach(track => track.stop());
          }
        };
        
        // 开始录音
        mediaRecorder.start(100); // 每100ms触发一次dataavailable事件
        isConverting = true;
        
        // 更新UI
        convertBtn.innerHTML = '<i class="fa fa-stop mr-2"></i>停止转换';
        convertBtn.classList.remove('bg-purple-500', 'hover:bg-purple-600');
        convertBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
        
        // 禁用其他按钮
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        
        updateStatus('开始转换为音频...');
        
        // 创建新的语音实例
        utterance = new SpeechSynthesisUtterance(text);
        
        // 设置语音参数
        const selectedVoice = voices.find(voice => voice.name === voiceSelect.value);
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        utterance.rate = parseFloat(rateInput.value);
        utterance.pitch = parseFloat(pitchInput.value);
        utterance.volume = parseFloat(volumeInput.value);
        
        // 特别处理：对于较长的文本，将其分段朗读和录制
        const MAX_TEXT_LENGTH = 3000; // 最大文本长度
        if (text.length > MAX_TEXT_LENGTH) {
          const paragraphs = text.split('\n');
          let currentChunk = '';
          let chunks = [];
          
          // 将文本分成合适大小的块
          for (const paragraph of paragraphs) {
            if ((currentChunk + paragraph).length > MAX_TEXT_LENGTH) {
              chunks.push(currentChunk.trim());
              currentChunk = paragraph + '\n';
            } else {
              currentChunk += paragraph + '\n';
            }
          }
          
          if (currentChunk.trim()) {
            chunks.push(currentChunk.trim());
          }
          
          console.log(`将文本分成 ${chunks.length} 块`);
          
          // 处理多块文本
          let currentIndex = 0;
          
          // 定义递归函数处理每个文本块
          const speakNextChunk = () => {
            if (currentIndex < chunks.length) {
              const chunk = chunks[currentIndex];
              utterance.text = chunk;
              
              // 更新进度
              const progress = Math.min(((currentIndex + 1) / chunks.length) * 100, 100);
              progressBar.style.width = `${progress}%`;
              
              // 为每个块设置事件监听
              utterance.onend = () => {
                console.log(`完成块 ${currentIndex + 1}/${chunks.length}`);
                currentIndex++;
                
                if (currentIndex < chunks.length) {
                  // 延迟一下再朗读下一块，避免音频中断
                  setTimeout(() => {
                    speechSynthesis.speak(utterance);
                  }, 500);
                } else {
                  // 所有块都朗读完成，停止录音
                  setTimeout(() => {
                    if (isConverting && mediaRecorder && mediaRecorder.state !== 'inactive') {
                      mediaRecorder.stop();
                    }
                  }, 1000);
                }
              };
              
              // 开始朗读当前块
              speechSynthesis.speak(utterance);
              currentIndex++;
            }
          };
          
          // 开始处理第一个块
          speakNextChunk();
        } else {
          // 短文本直接朗读
          utterance.onstart = () => {
            updateStatus('正在朗读并录制...');
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            console.log('开始朗读文本，长度:', text.length);
          };
          
          utterance.onboundary = (event) => {
            // 更新朗读进度
            spokenChars = event.charIndex + event.charLength;
            const progress = Math.min((spokenChars / totalChars) * 100, 100);
            progressBar.style.width = `${progress}%`;
          };
          
          utterance.onend = () => {
            console.log('语音朗读结束');
            // 语音朗读结束，延迟停止录音以确保所有音频数据都被捕获
            setTimeout(() => {
              if (isConverting && mediaRecorder && mediaRecorder.state !== 'inactive') {
                console.log('停止录音');
                mediaRecorder.stop();
              }
            }, 1000);
          };
          
          utterance.onerror = (event) => {
            console.error('语音朗读错误:', event.error);
            updateStatus(`发生错误: ${event.error}`, 'error');
            progressContainer.classList.add('hidden');
            
            // 发生错误，停止录音
            if (isConverting && mediaRecorder && mediaRecorder.state !== 'inactive') {
              mediaRecorder.stop();
            }
          };
          
          // 开始朗读（同时录制）
          speechSynthesis.speak(utterance);
        }
        
      } catch (error) {
        console.error('转换初始化失败:', error);
        showNotification(`转换失败: ${error.message}`, 'error');
        isConverting = false;
        convertBtn.innerHTML = '<i class="fa fa-magic mr-2"></i>转换为MP3';
        convertBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
        convertBtn.classList.add('bg-purple-500', 'hover:bg-purple-600');
        enableControlButtons();
      }
    }
    
    // 停止转换
    function finishConversion() {
      if (isConverting && mediaRecorder) {
        // 停止录音
        if (mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
        
        isConverting = false;
        convertBtn.innerHTML = '<i class="fa fa-magic mr-2"></i>转换为MP3';
        convertBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'recording-indicator');
        convertBtn.classList.add('bg-purple-500', 'hover:bg-purple-600');
        
        // 启用控制按钮
        enableControlButtons();
      }
    }
    
    // 转换为MP3格式
    async function convertToMP3(audioBlob) {
      return new Promise((resolve, reject) => {
        try {
          // 创建音频上下文
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const fileReader = new FileReader();
          
          fileReader.onload = async (event) => {
            try {
              // 解码音频数据
              const arrayBuffer = event.target.result;
              const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
              
              // 获取音频数据
              const numberOfChannels = audioBuffer.numberOfChannels;
              const length = audioBuffer.length;
              const sampleRate = audioBuffer.sampleRate;
              
              console.log(`音频信息: ${numberOfChannels}声道, ${length}采样点, ${sampleRate}Hz采样率`);
              
              // 合并所有声道数据
              const audioData = new Float32Array(length);
              for (let i = 0; i < length; i++) {
                let sum = 0;
                for (let channel = 0; channel < numberOfChannels; channel++) {
                  sum += audioBuffer.getChannelData(channel)[i];
                }
                audioData[i] = sum / numberOfChannels; // 平均化多声道
              }
              
              // 转换为16位整数
              const samples = new Int16Array(length);
              for (let i = 0; i < length; i++) {
                const s = Math.max(-1, Math.min(1, audioData[i]));
                samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
              }
              
              // 使用lame.js编码为MP3
              const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, 128); // 单声道，128kbps
              const mp3Data = [];
              
              const sampleBlockSize = 1152; // MP3编码的推荐块大小
              for (let i = 0; i < samples.length; i += sampleBlockSize) {
                const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
                if (mp3buf.length > 0) {
                  mp3Data.push(mp3buf);
                }
              }
              
              // 完成编码
              const mp3buf = mp3encoder.flush();
              if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
              }
              
              // 合并所有MP3数据
              const totalLength = mp3Data.reduce((acc, buf) => acc + buf.length, 0);
              const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
              
              console.log(`MP3编码完成: ${mp3Blob.size} 字节`);
              resolve(mp3Blob);
              
            } catch (error) {
              console.error('MP3转换失败:', error);
              reject(new Error(`MP3转换失败: ${error.message}`));
            } finally {
              audioContext.close();
            }
          };
          
          fileReader.onerror = () => {
            reject(new Error('文件读取失败'));
          };
          
          fileReader.readAsArrayBuffer(audioBlob);
          
        } catch (error) {
          reject(new Error(`MP3转换初始化失败: ${error.message}`));
        }
      });
    }
    
    // 下载音频
    downloadBtn.addEventListener('click', () => {
      if (!audioBlob) {
        showNotification('没有可下载的音频', 'warning');
        return;
      }
      
      try {
        // 创建下载链接
        const a = document.createElement('a');
        const url = URL.createObjectURL(audioBlob);
        a.href = url;
        
        // 生成MP3文件名
        const fileName = `text-to-speech_${new Date().toISOString().replace(/[:.]/g, '-')}.mp3`;
        a.download = fileName;
        
        // 触发下载
        document.body.appendChild(a);
        a.click();
        
        // 清理
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        
        showNotification('MP3文件下载已开始');
      } catch (error) {
        console.error('下载失败:', error);
        
        // 尝试备选下载方法
        try {
          if (navigator.msSaveBlob) {
            // 针对IE/Edge的下载方法
            navigator.msSaveBlob(audioBlob, 'text-to-speech.mp3');
            showNotification('MP3文件下载已开始（IE/Edge）');
          } else {
            // 尝试使用Blob直接下载
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64data = reader.result;
              const link = document.createElement('a');
              link.href = base64data;
              link.download = 'text-to-speech.mp3';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              showNotification('MP3文件下载已开始（备选方法）');
            };
            reader.readAsDataURL(audioBlob);
          }
        } catch (err) {
          showNotification('下载失败: ' + err.message, 'error');
        }
      }
    });
    
    // 更新状态信息
    function updateStatus(message, type = 'info') {
      statusMessage.textContent = message;
      
      if (type === 'error') {
        statusMessage.classList.add('text-red-600', 'dark:text-red-400');
      } else {
        statusMessage.classList.remove('text-red-600', 'dark:text-red-400');
      }
      
      statusInfo.classList.remove('hidden');
      
      // 如果是完成状态，3秒后隐藏
      if (message === '朗读已完成' || message === '已停止' || message === '转换完成') {
        setTimeout(() => {
          statusInfo.classList.add('hidden');
        }, 3000);
      }
    }
    
    // 更新控制按钮状态
    function updateControlButtons(playEnabled, pauseEnabled, stopEnabled) {
      playBtn.disabled = !playEnabled;
      pauseBtn.disabled = !pauseEnabled;
      stopBtn.disabled = !stopEnabled;
      
      // 如果正在转换，调整按钮状态
      if (isConverting) {
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
      }
    }
    
    // 启用控制按钮
    function enableControlButtons() {
      playBtn.disabled = false;
      stopBtn.disabled = false;
      pauseBtn.disabled = true;
      
      // 如果没有正在转换，允许点击转换按钮
      if (!isConverting) {
        convertBtn.disabled = false;
      }
    }
    
    // 页面卸载时清理资源
    window.addEventListener('beforeunload', () => {
      // 停止任何正在进行的语音
      stopSpeech();
      
      // 释放音频资源
      if (audioContext) {
        audioContext.close().catch(err => console.error('关闭音频上下文失败:', err));
      }
      
      // 释放音频URL
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    });
  </script>
</body>
</html>
  